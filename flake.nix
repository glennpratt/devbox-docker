{
  description = "Build a layered docker image using packages from a generated devbox flake";

  inputs = {
    # The devbox-generated flake (provides buildInputs and default nixpkgs)
    devbox-gen.url = "path:/project/.devbox/gen/flake";

    # nixpkgs can be overridden via --override-input to match devbox packages
    # Default follows devbox-gen's nixpkgs, but override for package alignment
    nixpkgs.follows = "devbox-gen/nixpkgs";

    # Decoupled build toolchain (pinned for caching)
    nixpkgs-build.url = "github:NixOS/nixpkgs/77ef7a29d276c6d8303aece3444d61118ef71ac2";
  };

  outputs =
    {
      self,
      devbox-gen,
      nixpkgs,
      nixpkgs-build,
      ...
    }:
    let
      system = builtins.head (builtins.attrNames devbox-gen.devShells);

      # Read environment variables from JSON file generated by entrypoint.sh
      # File contains: ["NAME=value", "NAME2=value2"]
      envVarsFile = /project/.devbox-env-vars.json;
      envVars =
        if builtins.pathExists envVarsFile then builtins.fromJSON (builtins.readFile envVarsFile) else [ ];

      # Use the (potentially overridden) nixpkgs for all base packages
      # This ensures glibc, bashInteractive, etc. match the devbox package deps
      pkgs = nixpkgs.legacyPackages.${system};
      buildPkgs = nixpkgs-build.legacyPackages.${system};

      # Get the dynamic linker path for this system
      dynamicLinker = "${pkgs.glibc}/lib/ld-linux-x86-64.so.2";

      # Base packages for all images
      baseContents = [
        pkgs.bashInteractive
        pkgs.coreutils
        buildPkgs.dockerTools.binSh
        buildPkgs.dockerTools.caCertificates
        buildPkgs.dockerTools.fakeNss
        buildPkgs.dockerTools.usrBinEnv
        # Include all devbox packages from the generated flake
        # Note: these come from the same nixpkgs as pkgs (potentially overridden)
        # to maintain version consistency
      ] ++ (devbox-gen.devShells.${system}.default.buildInputs or [])
        ++ (devbox-gen.devShells.${system}.default.nativeBuildInputs or []);

      # Additional packages for GitHub Actions compatibility
      ghaContents = [
        # nix-ld: shim dynamic linker for executing FHS binaries (like GHA's node)
        pkgs.nix-ld
        # Dependencies that GHA's node binary needs to find via nix-ld
        pkgs.glibc
        pkgs.stdenv.cc.cc.lib
        pkgs.zlib
        pkgs.openssl
        # Tools for actions/checkout
        pkgs.git
        pkgs.gnutar
        pkgs.gzip
        # SSH for actions that use deploy keys or ssh-agent
        pkgs.openssh
      ];

      # Build image with specified contents and optional GHA support
      buildImage =
        { includeGHA }:
        let
          # Only add GHA contents if requested
          finalContents = baseContents ++ (if includeGHA then ghaContents else [ ]);

          # NIX_LD_LIBRARY_PATH: libraries to be found by nix-ld for FHS binaries
          nixLdLibraryPath = pkgs.lib.makeLibraryPath [
            pkgs.glibc
            pkgs.stdenv.cc.cc.lib
            pkgs.zlib
            pkgs.openssl
          ];

          # Create /lib64/ld-linux-x86-64.so.2 symlink pointing to nix-ld
          # This intercepts execution of FHS binaries (using standard linker path)
          # and routes them through nix-ld, which sets up the environment correctly.
          finalExtraCommands =
            ''
              mkdir -p -m 1777 tmp
            '' + (if includeGHA then
              ''
                mkdir -p lib64
                ln -sf ${pkgs.nix-ld}/libexec/nix-ld lib64/ld-linux-x86-64.so.2

                # Add default SSH config to support /root/.ssh/config and known_hosts
                # Remove the default symlink from openssh package if it exists
                rm -f etc/ssh/ssh_config
                mkdir -p etc/ssh
                echo "Include /root/.ssh/config" > etc/ssh/ssh_config
                echo "UserKnownHostsFile /root/.ssh/known_hosts /etc/ssh/ssh_known_hosts" >> etc/ssh/ssh_config
              ''
            else
              "");

          # Only set special Env if requested
          # Base env + user-provided envVars from init_hook + GHA-specific if needed

          # Separate PATH_ADDITIONS from other envVars
          otherEnvVars = builtins.filter (v: !(pkgs.lib.hasPrefix "PATH_ADDITIONS=" v)) envVars;
          pathAddition =
            let
              match = builtins.filter (pkgs.lib.hasPrefix "PATH_ADDITIONS=") envVars;
            in
            if match == [ ] then "" else pkgs.lib.removePrefix "PATH_ADDITIONS=" (builtins.head match);

          finalEnv =
            [
              "USER=root"
              "PATH=${if pathAddition == "" then "" else pathAddition + ":"}/bin:/usr/bin"
              "SSL_CERT_FILE=/etc/ssl/certs/ca-bundle.crt"
            ]
            ++ otherEnvVars
            ++ (
              if includeGHA then
                [
                  "NIX_LD=${dynamicLinker}"
                  "NIX_LD_LIBRARY_PATH=${nixLdLibraryPath}"
                ]
              else
                [ ]
            );
        in
        buildPkgs.dockerTools.buildLayeredImage {
          name = image_name;
          tag = "latest";

          # No base image - pure Nix for minimal size
          contents = finalContents;

          # Create /lib64 symlink for glibc dynamic linker compatibility (GHA only)
          extraCommands = finalExtraCommands;

          config = {
            Cmd = [
              "/bin/bash"
              "-l"
            ];
            Env = finalEnv;
          };
        };
    in
    {
      packages.${system} = {
        # Minimal image without GitHub Actions support
        dockerImage = buildImage { includeGHA = false; };

        # Image with GitHub Actions compatibility
        ghaCompatImage = buildImage { includeGHA = true; };


      };

      defaultPackage.${system} = self.packages.${system}.dockerImage;
    };
}
